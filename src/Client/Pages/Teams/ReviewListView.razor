@inject ApiClient Api
@inject ISnackbar Snackbar
@inject IDialogService DialogService 

<MudList Dense="true" Class="flex-grow-1">
    <MudListSubheader>
        <MudText Typo="Typo.h6">@LootList.CharacterName</MudText>
        <MudText Typo="Typo.h6">
            Main Spec:
            <SpecIcon Spec="LootList.MainSpec" Size="IconSize.Tiny" />
            @LootList.MainSpec.GetDisplayName()
        </MudText>
        @if (LootList.OffSpec != LootList.MainSpec && LootList.OffSpec != default)
        {
            <MudText Typo="Typo.h6">
                Off Spec:
                <SpecIcon Spec="LootList.OffSpec" Size="IconSize.Tiny" />
                @LootList.OffSpec.GetDisplayName()
            </MudText>
        }
        <MudText Color="_messageColor" Inline="false">@_message</MudText>

        @if (LootList.Status == LootListStatus.Locked && LootList.TeamId == Team.Id)
        {
            <AuthorizeView Policy="@AppPolicies.Administrator">
                <MudTooltip Text="Revoking an approval will prevent this loot list from being eligible for rankings, and allow it to be edited by the owner.">
                    <MudButton OnClick="SetEditableAsync" Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.Clear" Color="Color.Error">
                        Revoke Approval
                    </MudButton>
                </MudTooltip>
                <MudTooltip Text="Unlocking a loot list will hide rankings from non-leaders. To allow it to be modified, use the Revoke Approval action instead.">
                    <MudButton OnClick="UnlockAsync" Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.LockOpen" Color="Color.Error" Class="ml-2">Unlock</MudButton>
                </MudTooltip>
            </AuthorizeView>
        }
        else if (LootList.Status == LootListStatus.Submitted || (!LootList.TeamId.HasValue && LootList.Status == LootListStatus.Locked))
        {
            <MudTooltip Text="Approving a loot list is considered an acceptance onto the raid team, but will not allow non-leaders to see rankings.">
                <MudButton OnClick="ApproveAndAddToRosterAsync" Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.Check" Color="Color.Primary">
                    Approve
                </MudButton>
            </MudTooltip>
            <MudTooltip Text="Denying a loot list may allow it to be edited by the owner.">
                <MudButton OnClick="DenyAsync" Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.Clear" Color="Color.Error">
                    Deny
                </MudButton>
            </MudTooltip>
        }
        else if (LootList.Status == LootListStatus.Approved)
        {
            <MudTooltip Text="Revoking an approval will prevent this loot list from being eligible for rankings, and allow it to be edited by the owner.">
                <MudButton OnClick="SetEditableAsync" Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.Clear" Color="Color.Error">
                    Revoke Approval
                </MudButton>
            </MudTooltip>
            <MudTooltip Text="Locking a loot list will make rankings visible to non-leaders and prevent editing. This should generally be done after approval of all loot lists on a team.">
                <MudButton OnClick="LockAsync" Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.Lock" Color="Color.Error" Class="ml-2">Lock</MudButton>
            </MudTooltip>
        }
    </MudListSubheader>
    @foreach (var row in _rows.OrderByDescending(g => g.Key))
    {
        <MudDivider />
        <MudListItem Class="mud-list-item-clickable" Style="cursor: auto" @key="row.Key">
            <MudGrid>
                <MudItem xs="12" md="3" lg="2">
                    <MudText Typo="Typo.h6" GutterBottom="false">Rank @row.Key</MudText>
                </MudItem>
                @foreach (var entry in row)
                {
                    @if (Items.FirstOrDefault(item => item.Id == entry.ItemId) is ItemDto item)
                    {
                        <MudItem xs="12" md="9 / _rowSize" lg="10 / _rowSize" @key="entry.Id">
                            <div class="d-flex align-center">
                                <CascadingItemContext Id="item.Id">
                                    @if (entry.Won)
                                    {
                                        <MudBadge Icon="@Icons.Material.Filled.Check" Color="Color.Success" Overlap="true">
                                            <MudAvatar Rounded="true" Class="mr-2">
                                                <ItemIcon Size="IconSize.Medium" Width="40" Height="40" />
                                            </MudAvatar>
                                        </MudBadge>
                                    }
                                    else
                                    {
                                        <MudAvatar Rounded="true" Class="mr-2">
                                            <ItemIcon Size="IconSize.Medium" Width="40" Height="40" />
                                        </MudAvatar>
                                    }
                                    <ItemLink LinkEnabled="true" Colorize="true" Bracketize="true" PlaceholderText="@item.Name" />
                                </CascadingItemContext>
                            </div>
                            <ul>
                                @foreach (var restriction in GetRestrictions(item, entry))
                                {
                                    <li>
                                        <MudText Color="restriction.Level == ItemRestrictionLevel.ManualReview ? Color.Warning : Color.Error">
                                            @restriction.Reason
                                        </MudText>
                                    </li>
                                }
                            </ul>
                            @if (entry.Justification?.Length > 0)
                            {
                                <div>
                                    Justification: @entry.Justification
                                </div>
                            }
                        </MudItem>
                    }
                }
            </MudGrid>
        </MudListItem>
    }
</MudList>

@code {
    private IEnumerable<IGrouping<int, LootListEntryDto>> _rows = Enumerable.Empty<IGrouping<int, LootListEntryDto>>();
    private int _rowSize;
    private Color _messageColor;
    private string? _message;

    [Parameter] public TeamDto Team { get; set; } = null!;
    [Parameter] public LootListDto LootList { get; set; } = null!;
    [Parameter] public IList<ItemDto> Items { get; set; } = null!;
    [Parameter] public System.Security.Claims.ClaimsPrincipal User { get; set; } = null!;
    [Parameter] public EventCallback<LootListDto> StatusUpdated { get; set; }
    [Parameter] public EventCallback RosterChanged { get; set; }

    protected override void OnParametersSet()
    {
        if (Team is null) throw new ArgumentNullException(nameof(Team));
        if (LootList is null) throw new ArgumentNullException(nameof(LootList));
        if (Items is null) throw new ArgumentNullException(nameof(Items));
        if (User is null) throw new ArgumentNullException(nameof(User));
        _rows = LootList.Entries.GroupBy(e => e.Rank);
        _rowSize = _rows.Select(row => row.Count()).Max();
        SetMessage();
    }

    private void SetMessage()
    {
        (_message, _messageColor) = LootList.Status switch
        {
            LootListStatus.Editing => ("Loot List is still being edited.", Color.Error),
            LootListStatus.Submitted => ("Loot List is submitted but awaiting approval.", Color.Warning),
            LootListStatus.Approved => ("Loot List has been approved, but still needs to be locked.", Color.Warning),
            LootListStatus.Locked when LootList.TeamId is null => ("Loot list is locked, but character is not on this team yet.", Color.Warning),
            LootListStatus.Locked => ("Loot List has been approved and locked!", Color.Success),
            _ => ("Unrecognized status!", Color.Error)
        };
    }

    private IEnumerable<RestrictionDto> GetRestrictions(ItemDto item, LootListEntryDto entry)
    {
        return item.GetRestrictions(LootList.MainSpec, LootList.OffSpec, entry.BracketAllowsOffspec);
    }

    private Task SetEditableAsync()
    {
        return Api.LootLists.SetEditable(LootList)
            .OnSuccess((_, _) =>
            {
                SetMessage();
                return StatusUpdated.InvokeAsync(LootList);
            })
            .SendErrorTo(Snackbar)
            .ExecuteAsync();
    }

    private Task LockAsync()
    {
        return Api.LootLists.Lock(LootList)
            .OnSuccess((_, _) =>
            {
                SetMessage();
                return StatusUpdated.InvokeAsync(LootList);
            })
            .SendErrorTo(Snackbar)
            .ExecuteAsync();
    }

    private Task UnlockAsync()
    {
        return Api.LootLists.Unlock(LootList)
            .OnSuccess((_, _) =>
            {
                SetMessage();
                return StatusUpdated.InvokeAsync(LootList);
            })
            .SendErrorTo(Snackbar)
            .ExecuteAsync();
    }

    private Task ApproveAndAddToRosterAsync()
    {
        return Api.LootLists.Approve(LootList, Team.Id)
            .OnSuccess(async (response, _) =>
            {
                LootList.TeamId = Team.Id;
                LootList.TeamName = Team.Name;
                SetMessage();
                StateHasChanged();
                await StatusUpdated.InvokeAsync(LootList);

                if (!Team.Roster.Any(m => m.Character.Id == LootList.CharacterId) && response.Member is not null)
                {
                    Team.Roster.Add(response.Member);
                    await RosterChanged.InvokeAsync();
                }
            })
            .SendErrorTo(Snackbar)
            .ExecuteAsync();
    }

    private Task DenyAsync()
    {
        return Api.LootLists.Reject(LootList, Team.Id)
            .OnSuccess((_, _) =>
            {
                SetMessage();
                return StatusUpdated.InvokeAsync(LootList);
            })
            .SendErrorTo(Snackbar)
            .ExecuteAsync();

    }
}
