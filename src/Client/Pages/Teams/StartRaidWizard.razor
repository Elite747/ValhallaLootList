@using ValhallaLootList.Client.Data.Import
@inject ApiClient Api
@inject NavigationManager Nav
@inject ISnackbar Snackbar
@inject IDialogService DialogService

<WizardDialog Title="Start Raid" OnFinish="OnFinishAsync">
    <ApiView Operations="new IApiClientOperation[] { _instancesOperation, _charactersOperation }">
        <WizardSection Name="RTO">
            <MudText Color="Color.Info">
                RTO: 
                @if (_rto.Count != 0)
                {
                    @string.Join(", ", _rto.Values.OrderBy(c => c.Name).Select(c => c.Name))
                }
                else
                {
                    @:None
                }
            </MudText>
            <div>
                @foreach (var classGroup in Team.Roster.GroupBy(m => m.Character.Class).OrderBy(g => g.Key.GetSortingIndex()))
                {
                    <MudText Typo="Typo.subtitle2" Class="mt-1">@classGroup.Key.GetDisplayName()</MudText>

                    @foreach (var member in classGroup.OrderBy(m => m.Character.Name))
                    {
                        <MemberChip Member="member"
                                    Phase="Phase"
                                    IsSelected="_rto.ContainsKey(member.Character.Id)"
                                    IsSelectedChanged="selected => SetRto(member.Character, selected)" />
                    }
                }
            </div>
        </WizardSection>
        <WizardSection Name="Import" CanContinue="ImportValid" ContinueText="@(string.IsNullOrWhiteSpace(_importString) ? "Skip" : "Next")">
            <MudTextField T="string"
                          Value="_importString"
                          ValueChanged="ImportOrClear"
                          FullWidth="true"
                          Immediate="true"
                          Label="Import Code"
                          Variant="Variant.Filled" />
            @if (_importString?.Length > 0 && ImportValid())
            {
                <MudAlert Severity="Severity.Success">
                    <div>Imported!</div>
                    <br />
                    @if (_absent.Count == 0)
                    {
                        <div>All Raiders Present</div>
                    }
                    else
                    {
                        <div>Absent: @GetAbsent()</div>
                    }
                    @if (_unrostered.Count != 0)
                    {
                        <br />
                        <div>Unrostered: @string.Join(", ", _unrostered.Values.OrderBy(c => c.Name).Select(c => c.Name))</div>
                    }
                </MudAlert>
            }

            @if (_importError?.Length > 0)
            {
                <MudAlert Severity="Severity.Error">Import failed. @_importError</MudAlert>
            }

            @foreach (var warning in _importWarnings)
            {
                <MudAlert Severity="Severity.Warning">@warning</MudAlert>
            }

            @if (_nonExistantCharacters.Count != 0)
            {
                <MudList Dense="true">
                    <MudListSubheader>
                        The following characters were imported but do not exist yet. Add or remove these characters to continue.
                    </MudListSubheader>
                    @foreach (var character in _nonExistantCharacters)
                    {
                        <MudListItem>
                            <div class="d-flex align-center">
                                <PlayerIcon Gender="character.Gender"
                                            PlayerClass="character.Class"
                                            Race="character.Race"
                                            ShowTooltip="true"
                                            Size="Size.Small" />
                                <MudText Class="mx-3">
                                    @character.Name
                                </MudText>
                                <MudTooltip Class="mr-1" Text="Add">
                                    <MudIconButton OnClick="() => AddNonExistantAsync(character)" Color="Color.Success" Icon="@Icons.Material.Filled.AddCircleOutline" />
                                </MudTooltip>
                                <MudTooltip Text="Remove">
                                    <MudIconButton OnClick="() => RemoveNonExistant(character)" Color="Color.Error" Icon="@Icons.Material.Filled.RemoveCircleOutline" />
                                </MudTooltip>
                            </div>
                        </MudListItem>
                    }
                </MudList>
            }
        </WizardSection>
        <WizardSection Name="Roster" CanContinue="() => _absent.Count < Team.Roster.Count">
            @if (_absent.Count > 0)
            {
                <MudText Color="Color.Warning">
                    Absent: @GetAbsent()
                </MudText>
            }
            <div>
                @foreach (var classGroup in Team.Roster.GroupBy(m => m.Character.Class).OrderBy(g => g.Key.GetSortingIndex()))
                {
                    <MudText Typo="Typo.subtitle2" Class="mt-1">@classGroup.Key.GetDisplayName()</MudText>

                    @foreach (var member in classGroup.OrderBy(m => m.Character.Name))
                    {
                        @if (_rto.ContainsKey(member.Character.Id))
                        {
                            <MemberChip Disabled IsSelected Member="member" Phase="Phase" />
                        }
                        else
                        {
                            <MemberChip Member="member"
                                        Phase="Phase"
                                        IsSelected="!_absent.ContainsKey(member.Character.Id)"
                                        IsSelectedChanged="selected => SetAttending(member.Character, selected)" />
                        }
                    }
                }
            </div>
        </WizardSection>
        <WizardSection Name="Additional Attendees">
            <div>
                @foreach (var character in _unrostered.Values.OrderBy(c => c.Name))
                {
                    <CharacterChip Closeable Character="character" OnClose="() => _unrostered.Remove(character.Id)" />
                }
                <MudIconButton Icon="@Icons.Material.Filled.AddCircle"
                               Color="Color.Success"
                               Size="Size.Small"
                               OnClick="AddAttendeeAsync" />
            </div>
        </WizardSection>
    </ApiView>
</WizardDialog>

@code {
    private IApiClientOperation<IList<InstanceDto>> _instancesOperation = null!;
    private IApiClientOperation<IList<CharacterDto>> _charactersOperation = null!;
    private readonly List<ImportCharacter> _nonExistantCharacters = new();
    private readonly List<string> _importWarnings = new();
    private string? _importString, _importError;
    private readonly Dictionary<long, CharacterDto> _absent = new();
    private readonly Dictionary<long, CharacterDto> _rto = new();
    private readonly Dictionary<long, CharacterDto> _unrostered = new();

    [Parameter] public TeamDto Team { get; set; } = null!;
    [Parameter] public byte Phase { get; set; }

    protected override void OnInitialized()
    {
        _instancesOperation = Api.Instances.GetAll();
        _charactersOperation = Api.Characters.GetActive();
    }

    protected override void OnParametersSet()
    {
        if (Team is null) throw new ArgumentNullException(nameof(Team));
    }

    private bool ImportValid() => _nonExistantCharacters.Count == 0 && string.IsNullOrEmpty(_importError);

    private void ImportOrClear(string importString)
    {
        _importString = importString;
        _importError = null;
        _importWarnings.Clear();
        _nonExistantCharacters.Clear();

        if (importString?.Length > 0)
        {
            ImportRaidStartModel? model;
            try
            {
                model = System.Text.Json.JsonSerializer.Deserialize<ImportRaidStartModel>(importString);
            }
            catch (System.Text.Json.JsonException ex)
            {
                _importError = ex.Message;
                return;
            }
            if (model is not null)
            {
                if (model.Characters?.Count > 0)
                {
                    var allCharacters = _charactersOperation.GetResult();
                    _absent.Clear();
                    _unrostered.Clear();

                    // When importing, default all characters as absent.
                    foreach (var member in Team.Roster)
                    {
                        SetAttending(member.Character, false);
                    }

                    foreach (var importCharacter in model.Characters)
                    {
                        if (string.IsNullOrEmpty(importCharacter.Name))
                        {
                            _importError = "One or more characters does not have a name specified.";
                            return;
                        }

                        var character = allCharacters.FirstOrDefault(c => c.Name == importCharacter.Name);

                        if (character is null)
                        {
                            if (importCharacter.Class == Classes.None || !Enum.IsDefined(importCharacter.Class))
                            {
                                _importError = $"One or more characters does not have a valid class.";
                                return;
                            }

                            if (!Enum.IsDefined(importCharacter.Gender))
                            {
                                _importError = $"One or more characters does not have a valid gender.";
                                return;
                            }

                            if (!Enum.IsDefined(importCharacter.Race))
                            {
                                _importError = $"One or more characters does not have a valid race.";
                                return;
                            }

                            _nonExistantCharacters.Add(importCharacter);
                        }
                        else
                        {
                            if (importCharacter.Class != character.Class || importCharacter.Gender != character.Gender || importCharacter.Race != character.Race)
                            {
                                _importWarnings.Add($"{character.Name} was imported as a {importCharacter.Gender} {importCharacter.Race.GetDisplayName()} {importCharacter.Class.GetDisplayName()}, " +
                                    $"but is supposed to be a {character.Gender} {character.Race.GetDisplayName()} {character.Class.GetDisplayName()}.");
                            }

                            SetAttending(character, true);
                        }
                    }
                }
            }
            else
            {
                _importError = "Import text is not valid.";
            }
        }
    }

    private Task AddNonExistantAsync(ImportCharacter character)
    {
        return Api.Characters.Create(new() { Class = character.Class, Gender = character.Gender, Race = character.Race, Name = character.Name, SenderIsOwner = false })
            .OnSuccess(c =>
            {
                _nonExistantCharacters.Remove(character);
                _charactersOperation.GetResult().Add(c);
                SetAttending(c, true);
                StateHasChanged();
            })
            .SendErrorTo(Snackbar)
            .ExecuteAsync();
    }

    private void RemoveNonExistant(ImportCharacter character)
    {
        _nonExistantCharacters.Remove(character);
    }

    private void SetAttending(CharacterDto character, bool attending)
    {
        if (!_rto.ContainsKey(character.Id))
        {
            if (attending)
            {
                if (character.TeamId == Team.Id)
                {
                    _absent.Remove(character.Id);
                }
                else
                {
                    _unrostered[character.Id] = character;
                }
            }
            else if (character.TeamId == Team.Id)
            {
                _absent[character.Id] = character;
            }
            else
            {
                _unrostered.Remove(character.Id);
            }
        }
    }

    private void SetRto(CharacterDto character, bool rto)
    {
        System.Diagnostics.Debug.Assert(character.TeamId == Team.Id);

        if (_rto.ContainsKey(character.Id))
        {
            if (!rto)
            {
                _rto.Remove(character.Id);
                _absent[character.Id] = character;
            }
        }
        else if (rto)
        {
            _rto[character.Id] = character;
            _absent.Remove(character.Id);
        }
    }

    private async Task OnFinishAsync(System.ComponentModel.CancelEventArgs arg)
    {
        var attendees = new List<long>();

        foreach (var rosteredId in Team.Roster.Select(m => m.Character.Id))
        {
            if (!_rto.ContainsKey(rosteredId) && !_absent.ContainsKey(rosteredId))
            {
                attendees.Add(rosteredId);
            }
        }

        attendees.AddRange(_unrostered.Keys);

        var dto = new RaidSubmissionDto
        {
            Attendees = attendees,
            Rto = _rto.Keys.ToList(),
            Phase = Phase,
            TeamId = Team.Id
        };

        await Api.Raids.Create(dto)
            .OnSuccess(raid => Nav.NavigateTo("/raids/" + raid.Id))
            .OnFailure(_ => arg.Cancel = true)
            .SendErrorTo(Snackbar)
            .ExecuteAsync();
    }

    private async Task AddAttendeeAsync()
    {
        var character = await DialogService.ShowAsync<Raids.PickCharacterDialog, CharacterDto>(
            string.Empty,
            new() {
                [nameof(Raids.PickCharacterDialog.Operation)] = _charactersOperation,
                [nameof(Raids.PickCharacterDialog.Filter)] = (Func<CharacterDto, bool>)(c => c.TeamId != Team.Id),
                [nameof(Raids.PickCharacterDialog.ShowAdd)] = true
            },
            new() { NoHeader = true, MaxWidth = MaxWidth.ExtraSmall, FullWidth = true });

        if (character is not null)
        {
            SetAttending(character, true);
        }
    }

    private string GetAbsent() => string.Join(", ", _absent.Values.OrderBy(c => c.Name).Select(c => c.Name));
}
