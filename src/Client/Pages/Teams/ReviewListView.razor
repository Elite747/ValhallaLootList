@inject ApiClient Api
@inject ISnackbar Snackbar
@inject IDialogService DialogService 

<MudList Dense="true" Class="flex-grow-1">
    <MudListSubheader>
        <MudText Typo="Typo.h6">@LootList.CharacterName</MudText>
        <MudText Color="_messageColor" Inline="false">@_message</MudText>

        @if (LootList.Status == LootListStatus.Locked)
        {
            <AuthorizeView Policy="@AppPolicies.Administrator">
                <MudTooltip Text="Revoking an approval will prevent this loot list from being eligible for rankings, and allow it to be edited by the owner.">
                    <MudButton OnClick="() => ChangeStatusAsync(LootListStatus.Editing)" Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.Clear" Color="Color.Error">
                        Revoke Approval
                    </MudButton>
                </MudTooltip>
                <MudTooltip Text="Unlocking a loot list will hide rankings from non-leaders. To allow it to be modified, use the Revoke Approval action instead.">
                    <MudButton OnClick="() => ChangeStatusAsync(LootListStatus.Approved, true)" Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.LockOpen" Color="Color.Error" Class="ml-2">Unlock</MudButton>
                </MudTooltip>
            </AuthorizeView>
        }
        else if (LootList.Status == LootListStatus.Submitted)
        {
            <MudTooltip Text="Approving a loot list is considered an acceptance onto the raid team, but will not allow non-leaders to see rankings.">
                <MudButton OnClick="() => ChangeStatusAsync(LootListStatus.Approved)" Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.Check" Color="Color.Primary">
                    Approve Loot List
                </MudButton>
            </MudTooltip>
            <MudTooltip Text="Denying a loot list will allow it to be edited by the owner.">
                <MudButton OnClick="() => ChangeStatusAsync(LootListStatus.Editing)" Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.Clear" Color="Color.Error">
                    Deny Loot List
                </MudButton>
            </MudTooltip>
        }
        else if (LootList.Status == LootListStatus.Approved)
        {
            <MudTooltip Text="Revoking an approval will prevent this loot list from being eligible for rankings, and allow it to be edited by the owner.">
                <MudButton OnClick="() => ChangeStatusAsync(LootListStatus.Editing)" Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.Clear" Color="Color.Error">
                    Revoke Approval
                </MudButton>
            </MudTooltip>
            <MudTooltip Text="Locking a loot list will make rankings visible to non-leaders and prevent editing. This should generally be done after approval of all loot lists on a team.">
                <MudButton OnClick="() => ChangeStatusAsync(LootListStatus.Locked)" Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.Lock" Color="Color.Error" Class="ml-2">Lock</MudButton>
            </MudTooltip>
        }
    </MudListSubheader>
    @foreach (var row in _rows.OrderByDescending(g => g.Key))
    {
        <MudDivider />
        <MudListItem Class="mud-list-item-clickable" Style="cursor: auto">
            <MudGrid>
                <MudItem xs="12" md="3" lg="2">
                    <MudText Typo="Typo.h6" GutterBottom="false">Rank @row.Key</MudText>
                </MudItem>
                @foreach (var entry in row)
                {
                    @if (Items.FirstOrDefault(item => item.Id == entry.ItemId) is ItemDto item)
                    {
                        <MudItem xs="12" md="9 / _rowSize" lg="10 / _rowSize">
                            <div class="d-flex align-center">
                                <CascadingItemContext Id="item.Id">
                                    @if (entry.Won)
                                    {
                                        <MudBadge Icon="@Icons.Material.Filled.Check" Color="Color.Success" Overlap="true">
                                            <MudAvatar Rounded="true" Class="mr-2">
                                                <ItemIcon Size="IconSize.Medium" Width="40" Height="40" />
                                            </MudAvatar>
                                        </MudBadge>
                                    }
                                    else
                                    {
                                        <MudAvatar Rounded="true" Class="mr-2">
                                            <ItemIcon Size="IconSize.Medium" Width="40" Height="40" />
                                        </MudAvatar>
                                    }
                                    <ItemLink LinkEnabled="true" Colorize="true" Bracketize="true" PlaceholderText="@item.Name" />
                                </CascadingItemContext>
                            </div>
                            <ul>
                                @foreach (var restriction in GetRestrictions(item, entry))
                                {
                                    <li>
                                        <MudText Color="restriction.Level == ItemRestrictionLevel.ManualReview ? Color.Warning : Color.Error">
                                            @restriction.Reason
                                        </MudText>
                                    </li>
                                }
                            </ul>
                        </MudItem>
                    }
                }
            </MudGrid>
        </MudListItem>
    }
</MudList>

@code {
    private IEnumerable<IGrouping<int, LootListEntryDto>> _rows = Enumerable.Empty<IGrouping<int, LootListEntryDto>>();
    private int _rowSize;
    private Color _messageColor;
    private string? _message;

    [Parameter] public LootListDto LootList { get; set; } = null!;
    [Parameter] public IList<ItemDto> Items { get; set; } = null!;
    [Parameter] public System.Security.Claims.ClaimsPrincipal User { get; set; } = null!;
    [Parameter] public EventCallback<LootListDto> StatusUpdated { get; set; }

    protected override void OnParametersSet()
    {
        if (LootList is null) throw new ArgumentNullException(nameof(LootList));
        if (Items is null) throw new ArgumentNullException(nameof(Items));
        if (User is null) throw new ArgumentNullException(nameof(User));
        _rows = LootList.Entries.GroupBy(e => e.Rank);
        _rowSize = _rows.Select(row => row.Count()).Max();
        SetMessage();
    }

    private void SetMessage()
    {
        (_message, _messageColor) = LootList.Status switch
        {
            LootListStatus.Editing => ("Loot List is still being edited.", Color.Error),
            LootListStatus.Submitted => ("Loot List is submitted but awaiting approval.", Color.Warning),
            LootListStatus.Approved => ("Loot List has been approved, but still needs to be locked.", Color.Warning),
            LootListStatus.Locked => ("Loot List has been approved and locked!", Color.Success),
            _ => ("Unrecognized status!", Color.Error)
        };
    }

    private IEnumerable<RestrictionDto> GetRestrictions(ItemDto item, LootListEntryDto entry)
    {
        var restrictions = item.Restrictions.Where(r => (r.Specs & LootList.MainSpec) != 0);

        if (entry.BracketAllowsOffspec && LootList.OffSpec != LootList.MainSpec)
        {
            if (restrictions.Any() ^ item.Restrictions.Any(r => (r.Specs & LootList.OffSpec) != 0))
            {
                return Array.Empty<RestrictionDto>();
            }
        }

        return restrictions.OrderBy(r => r.Level);
    }

    private Task ChangeStatusAsync(LootListStatus status, bool suppressMessage = false)
    {
        return Api.LootLists.SetStatus(LootList.CharacterId, LootList.Phase, new() { Status = status })
            .OnSuccess(async (_, _) =>
            {
                LootList.Status = status;
                if (!suppressMessage && status == LootListStatus.Approved)
                {
                    LootList.ApprovedBy = User.GetDiscordIdFromClient();
                    await DialogService.ShowMessageBox("Approved", "Loot list has been approved! Don't forget to add this character to the roster if you haven't already.");
                }
                SetMessage();
                await StatusUpdated.InvokeAsync(LootList);
            })
            .SendErrorTo(Snackbar)
            .ExecuteAsync();
    }
}
